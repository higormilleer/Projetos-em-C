/*Considerando filas, implemente um método que receba como parâmetro
a referência f1 e um valor de matrícula n e dívida a fila em duas, de tal
forma que a segunda fila comece no primeiro nó logo após a primeira
ocorrência de n na fila original. Esse método deve ser da seguinte
assinatura:
int separa(Fila f1, Fila f2, matricula n)
Dentro do método separa, a segunda fila deve ser apontada pela
referência f2, enquanto f1 deve continuar apontando para o início da fila
anterior. */

#include <stdio.h>
#include <stdlib.h>

typedef struct no{
    int dados;
    struct elemento *proximo;
}Node;

typedef struct fila{
    struct no *inicio;
    struct no *final;
    int qtd;
}Fila;

Fila* criaFila(){
    Fila* f = (Fila*)malloc(sizeof(Fila));
    if(f!=NULL){
        f->final = NULL;
        f->inicio=NULL;
        f->qtd=0;
    }
    return f;
}

void imprimirFila(Fila *f){
    if(f==NULL) return;

    Node *no = f->inicio;
    int i = 0;
    while(no!=NULL){
        printf("%d: %d ",i, no->dados);
        no = no->proximo;
        i++;
    }
}

void pushFi(Fila *f, int dados){
    if(f==NULL)return;

    Node *no = (Node*)malloc(sizeof(Node));
    if(no==NULL)return;

    no->dados = dados;
    no->proximo = NULL;

    if(f->final==NULL){
        f->inicio=no;
    }

    else{
        f->final->proximo=no;
    }
    f->final = no;
    f->qtd++;
    return;
}

void popFi(Fila *f){
    if(f==NULL)return;

    Node *no = f->inicio;
    f->inicio = f->inicio->proximo;
    if(f->inicio==NULL)f->final = NULL;
    free(no);
    f->qtd--;
    return;
}

void liberarPilha(Fila *f){
    if(f!=NULL){
        Node *no;
        while(f->inicio!=NULL){
            no = f->inicio;
            f->inicio = f->inicio->proximo;
            free(no);
        }
        free(f);
    }
}

int separa(Fila f1, Fila f2, matricula n)
{


}

int main(){




}

